$date
	Wed Sep 27 22:44:20 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module ALU_Testbench $end
$var wire 1 ! zeroFlag $end
$var wire 32 " result [31:0] $end
$var wire 1 # carryFlag $end
$var reg 4 $ aluOp [3:0] $end
$var reg 32 % operandA [31:0] $end
$var reg 32 & operandB [31:0] $end
$var reg 1 ' shiftAmount $end
$scope module UUT $end
$var wire 4 ( aluOp [3:0] $end
$var wire 32 ) operandA [31:0] $end
$var wire 32 * operandB [31:0] $end
$var wire 32 + res [31:0] $end
$var wire 1 ' shiftAmount $end
$var wire 1 ! zeroFlag $end
$var wire 1 # carryFlag $end
$var parameter 4 , ADD_OP $end
$var parameter 4 - AND_OP $end
$var parameter 4 . NOT_OP $end
$var parameter 4 / OR_OP $end
$var parameter 4 0 SLA_OP $end
$var parameter 4 1 SRA_OP $end
$var parameter 4 2 SRL_OP $end
$var parameter 4 3 SUB_OP $end
$var parameter 4 4 XOR_OP $end
$var reg 32 5 result [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b100 4
b1 3
b1000 2
b111 1
b110 0
b11 /
b101 .
b10 -
b0 ,
$end
#0
$dumpvars
b101000 5
b101000 +
b1010 *
b11110 )
b0 (
0'
b1010 &
b11110 %
b0 $
0#
b101000 "
0!
$end
#10
b10100 "
b10100 +
b10100 5
b1 $
b1 (
#20
b10 "
b10 +
b10 5
b10 $
b10 (
b11 &
b11 *
b1110 %
b1110 )
#30
b1111 "
b1111 +
b1111 5
b11 $
b11 (
#40
b1101 "
b1101 +
b1101 5
b100 $
b100 (
#50
b1111 "
b1111 +
b1111 5
b101 $
b101 (
b11111111111111111111111111110000 %
b11111111111111111111111111110000 )
#60
b1110 "
b1110 +
b1110 5
1'
b110 $
b110 (
b111 %
b111 )
#70
b11111111111111111111111111111111 "
b11111111111111111111111111111111 +
b11111111111111111111111111111111 5
b111 $
b111 (
b11111111111111111111111111111110 %
b11111111111111111111111111111110 )
#80
b111 "
b111 +
b111 5
b1000 $
b1000 (
b1110 %
b1110 )
#180
